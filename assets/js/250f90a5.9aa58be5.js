"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4677],{2097:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var i=t(5893),s=t(1151);const a={sidebar_position:4.5},r="Input Emulation",o={id:"design/input-emulation",title:"Input Emulation",description:"The most crucial part to the Pod Arcade experience is getting input from the Browser to the Desktop. This page explains some of the challenges we faced when designing this system, and what Linux hacks we had to implement to make it work. This page assumes a basic understanding of how Linux handles input devices.",source:"@site/docs/design/input-emulation.md",sourceDirName:"design",slug:"/design/input-emulation",permalink:"/docs/design/input-emulation",draft:!1,unlisted:!1,editUrl:"https://github.com/pod-arcade/website/tree/main/docs/design/input-emulation.md",tags:[],version:"current",sidebarPosition:4.5,frontMatter:{sidebar_position:4.5},sidebar:"tutorialSidebar",previous:{title:"Streaming",permalink:"/docs/design/streaming"},next:{title:"Peer-to-Peer Connection",permalink:"/docs/design/peer-to-peer"}},d={},c=[{value:"Gamepad",id:"gamepad",level:2},{value:"1. Connect",id:"1-connect",level:3},{value:"2. Connect (Application Side)",id:"2-connect-application-side",level:3},{value:"3. Create a gamepad using /dev/uinput",id:"3-create-a-gamepad-using-devuinput",level:3},{value:"4. Kernel \u2014 Load gamepad driver and populate /sys directory",id:"4-kernel--load-gamepad-driver-and-populate-sys-directory",level:3},{value:"5. Broadcast Kevent",id:"5-broadcast-kevent",level:3},{value:"6. Receive device created Kevent",id:"6-receive-device-created-kevent",level:3},{value:"7. Map device to a local path",id:"7-map-device-to-a-local-path",level:3},{value:"8. Call mknod with the device&#39;s major and minor version",id:"8-call-mknod-with-the-devices-major-and-minor-version",level:3},{value:"9. Resend the Kernel&#39;s event as a Udev event",id:"9-resend-the-kernels-event-as-a-udev-event",level:3},{value:"10. Application Receives a notification from &quot;udevd&quot;",id:"10-application-receives-a-notification-from-udevd",level:3},{value:"11. Application opens virtual device",id:"11-application-opens-virtual-device",level:3},{value:"Keyboard / Mouse",id:"keyboard--mouse",level:2},{value:"Helpful References",id:"helpful-references",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"input-emulation",children:"Input Emulation"}),"\n",(0,i.jsx)(n.p,{children:"The most crucial part to the Pod Arcade experience is getting input from the Browser to the Desktop. This page explains some of the challenges we faced when designing this system, and what Linux hacks we had to implement to make it work. This page assumes a basic understanding of how Linux handles input devices."}),"\n",(0,i.jsx)(n.h2,{id:"gamepad",children:"Gamepad"}),"\n",(0,i.jsxs)(n.p,{children:["One of the challenges that Pod Arcade had to overcome was the the creation of virtual gamepad devices inside of Docker, and expose them using the udev interface in Linux. Unfortunately, ",(0,i.jsx)(n.code,{children:"uinput"})," and ",(0,i.jsx)(n.code,{children:"udevd"})," aren't container aware, so we can only do so much to keep things isolated to containers. While we are able to control device visibility inside of our containers, we aren't able to prevent the host from seeing those virtual devices. As a result, it's recommended that you only use this on a headless server, not a workstation."]}),"\n",(0,i.jsxs)(n.p,{children:["This code aims to utilize the same ",(0,i.jsx)(n.code,{children:"uinput"})," and ",(0,i.jsx)(n.code,{children:"udev"})," APIs to work with existing software for discovering these virtual gamepads."]}),"\n",(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n  autonumber\n  participant Kernel\n  participant UdevKernelGrp\n  participant VirtualGamepad\n  participant UdevUserGrp\n  participant DeviceUEvent\n  participant Application\n\n  VirtualGamepad->>UdevKernelGrp: Connect\n  Application->>UdevUserGrp: Connect\n    note right of Kernel: The Kernel and <br/> UDevKernelGrp <br/> are not namespaced.<br/>Events will be sent across <br> net namespaces.\n\n  loop For Every Gamepad\n    VirtualGamepad->>Kernel: Create Gamepad using /dev/uinput\n    Kernel->>Kernel: Load gamepad driver <br/> and populate /sys dir\n    Kernel->>UdevKernelGrp: Broadcast kevent <br/> that a device was<br/> created with <br/> major:minor id <br/> and syspath\n    UdevKernelGrp->>VirtualGamepad: Receive device created <br/> Kevent\n    VirtualGamepad->>VirtualGamepad: Map device to a local path.<br/>calling mknod with the major <br/> and minor id provided by the<br/> Kernel. Ignore devices that <br/> aren't ours.\n    VirtualGamepad->>DeviceUEvent: call mknod with the device's major and minor version <br/> from the kernel. Applications will use <br/> this file to communicate with our gamepad.\n    VirtualGamepad->>UdevUserGrp: Resend the Kernel's event <br/> using our modified <br/> paths\n    UdevUserGrp->>Application: Receive a notification from \"udevd\" <br/> That a new device was created <br/> at the path indicated in the message.\n    Application->>DeviceUEvent: Connect to device\n  end"}),"\n",(0,i.jsx)(n.h3,{id:"1-connect",children:"1. Connect"}),"\n",(0,i.jsx)(n.p,{children:"Our application starts up, and opens a connection to the Kernel. This connection will be used to receive events when devices are created. The reason we need this, is that we can't simply emit events directly without knowing the device information assigned by the Kernel. As far as I know, the only way of receiving this information is to listen for those Kevents sent by the kernel. Opening this socket looks like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",metastring:"showLineNumbers",children:"\n// ...\n\nconst (\n  KernelEvent Mode = 1\n  UdevEvent Mode = 2\n)\n\n// ...\n\nif c.Fd, err = syscall.Socket(syscall.AF_NETLINK, syscall.SOCK_RAW, syscall.NETLINK_KOBJECT_UEVENT); err != nil {\n  return\n}\n\nc.Addr = syscall.SockaddrNetlink{\n  Family: syscall.AF_NETLINK,\n  Groups: uint32(mode), // Mode determines the group, Kernel or Udev\n}\n\nif err = syscall.Bind(c.Fd, &c.Addr); err != nil {\n  syscall.Close(c.Fd)\n}\n\n// ...\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Crucially, one other thing that we need to do is create the ",(0,i.jsx)(n.code,{children:"/run/udev"})," directory, and create a ",(0,i.jsx)(n.code,{children:"/run/udev/control"})," file. These files aren't used for anything, but the libudev library checks for the existence of these files to ensure that an instance of udev is running. It never reads to or writes to this file, only checks for its existence before subscribing to udev events."]}),"\n",(0,i.jsx)(n.h3,{id:"2-connect-application-side",children:"2. Connect (Application Side)"}),"\n",(0,i.jsx)(n.p,{children:"Similar to how we subscribe to the Kernel group to receive device events over the netlink socket, applications normally subscribe to the Udev group."}),"\n",(0,i.jsxs)(n.p,{children:["Udevd is the userspace program that typically listens to these events from the kernel, enriches them with information from a hardware database, and re-emits them. It also has a set of rules that it executes when messages from the kernel match a set of filters. These rules can be used to do things like run a program that calibrates the joystick device, or other various things that don't have a direct subscription to Udev. Applications typically subscribe to this using ",(0,i.jsx)(n.code,{children:"libudev"}),", which is a library used for interacting with the userspace daemon."]}),"\n",(0,i.jsxs)(n.p,{children:["In our case, we're aiming to replace much of this userspace program's functionality. We have to do some trickery in order to get ",(0,i.jsx)(n.code,{children:"libudev"})," to actually believe that there's a running udev instance and make the subscription. We do this by ",(0,i.jsx)(n.code,{children:"touch"}),"ing the ",(0,i.jsx)(n.code,{children:"/run/udev/control"})," file."]}),"\n",(0,i.jsx)(n.h3,{id:"3-create-a-gamepad-using-devuinput",children:"3. Create a gamepad using /dev/uinput"}),"\n",(0,i.jsx)(n.p,{children:"The /dev/uinput interface serves as a user-space API for creating and managing input devices at the kernel level. In essence, it enables you to create virtual input devices such as keyboards, mice, joysticks, or gamepads that the operating system treats as actual hardware devices. In order to use this interface, we need to bind through the host's interface."}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["This isn't technically true. We can use mknod to recreate the /dev/uinput file, as long as we have the major",":minor"," version supplied by the kernel, but mounting it through is the easiest way. ",(0,i.jsx)(n.code,{children:"c10:223"})," is what the device was on my machine, but I'm not sure if it's the same for everyone. ",(0,i.jsx)(n.code,{children:'stat --format="%t %T" /dev/uinput'})," should give you the device numbers ",(0,i.jsx)(n.strong,{children:"in hexadecimal format"})]})}),"\n",(0,i.jsx)(n.p,{children:"Regardless, by writing ioctl commands to this device, we can create a Virtual Gamepad."}),"\n",(0,i.jsx)(n.h3,{id:"4-kernel--load-gamepad-driver-and-populate-sys-directory",children:"4. Kernel \u2014 Load gamepad driver and populate /sys directory"}),"\n",(0,i.jsxs)(n.p,{children:["The Kernel takes those ioctl commands, and loads the appropriate input driver. I'm not sure exactly how all of that happens, but it then creates the /sys directory entry for that device, in ",(0,i.jsx)(n.code,{children:"/sys/devices/virtual/input/"}),". Unfortunately, this stage is ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.em,{children:"NOT"})})," restricted to your container. The /sys entry is created in every container, and on the host. Additionally, the events emitted in the next step are also emitted to everyone. This means that if your host is running ",(0,i.jsx)(n.code,{children:"udevd"})," (which it likely is), those virtual devices will show up on your host. We're investigating ways of preventing this, but for now... virtual devices created in your container will show up on the host as well."]}),"\n",(0,i.jsx)(n.h3,{id:"5-broadcast-kevent",children:"5. Broadcast Kevent"}),"\n",(0,i.jsxs)(n.p,{children:["When a device is connected, the kernel writes a message that looks something like this over the netlink socket we're subscribed to.\nIt's a series of strings that represents device information. It always begins with a header that sigals what the ",(0,i.jsx)(n.code,{children:"ACTION"})," is and on what ",(0,i.jsx)(n.code,{children:"DEVPATH"})," it occurs on."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"add@/class/input/input9/mouse2\\0\nACTION=add\\0\nDEVPATH=/class/input/input9/mouse2\\0\nSUBSYSTEM=input\\0\nSEQNUM=1064\\0\nPHYSDEVPATH=/devices/pci0000:00/0000:00:1d.1/usb2/2\xad2/2\xad2:1.0\\0\nPHYSDEVBUS=usb\\0\nPHYSDEVDRIVER=usbhid\\0\nMAJOR=13\\0\nMINOR=34\\0\n"})}),"\n",(0,i.jsx)(n.h3,{id:"6-receive-device-created-kevent",children:"6. Receive device created Kevent"}),"\n",(0,i.jsx)(n.p,{children:"Our application receives and parses the message sent from the kernel. This gets it ready for step 7."}),"\n",(0,i.jsx)(n.h3,{id:"7-map-device-to-a-local-path",children:"7. Map device to a local path"}),"\n",(0,i.jsxs)(n.p,{children:["Now that we have the device major and minor number, we can map this to a file in our container. When determining if we should process a message from the given ",(0,i.jsx)(n.code,{children:"<DEVNAME>"}),", we compare it to the syspath queried using ",(0,i.jsx)(n.code,{children:"ioctl"})," for our gamepad."]}),"\n",(0,i.jsxs)(n.p,{children:["Because we may have multiple containers, the event for one of our virtual gamepads may come in looking like: ",(0,i.jsx)(n.code,{children:"add@/devices/virtual/input/input378/js4"}),". Unfortunately, some legacy applications don't look for gamepad devices beyond ",(0,i.jsx)(n.code,{children:"js0-3"}),". This isn't as much of a problem with programs that use the new ",(0,i.jsx)(n.code,{children:"libevdev"})," devices, but for older ones, they won't detect the newly plugged in gamepad. Instead, we map this js4 device back to js0 for our container. This doesn't affect the path assigned by the Kernel, but any further events emitted from our application will now use the mapped ",(0,i.jsx)(n.code,{children:"js0-3"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Additionally, we need to map not just the legacy ",(0,i.jsx)(n.code,{children:"jsX"})," devices, but also the ",(0,i.jsx)(n.code,{children:"eventXYZ"})," devices. If it's the ",(0,i.jsx)(n.code,{children:"eventXYZ"}),", we don't make any changes and map the device as is."]}),"\n",(0,i.jsxs)(n.p,{children:["If we find a match, we know that the device belongs to us. If it's a legacy ",(0,i.jsx)(n.code,{children:"jsX"})," device, we'll map it to it's index in our gamepad hub. Both of these devices are mapped to ",(0,i.jsx)(n.code,{children:"/dev/input/js0-3"}),", or ",(0,i.jsx)(n.code,{children:"/dev/input/eventXYZ"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"8-call-mknod-with-the-devices-major-and-minor-version",children:"8. Call mknod with the device's major and minor version"}),"\n",(0,i.jsxs)(n.p,{children:["Once we've mapped it to the desired path, we'll make syscalls equivalent to ",(0,i.jsx)(n.code,{children:"mknod c <major> <minor> /dev/input/jsX"})," and ",(0,i.jsx)(n.code,{children:"mknod c <major> <minor> /dev/input/eventXYZ"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"9-resend-the-kernels-event-as-a-udev-event",children:"9. Resend the Kernel's event as a Udev event"}),"\n",(0,i.jsx)(n.p,{children:"After we create the local device path using mknod, we can modify and resend the events using the udev format. This is an internal format used only by udevd and libudev. The format of this additional message looks something like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'// C code taken from device-monitor.c\n\ntypedef struct monitor_netlink_header {\n  /* "libudev" prefix to distinguish libudev and kernel messages */\n  char prefix[8];\n  /* Magic to protect against daemon <-> Library message format mismatch\n    * Used in the kernel from socket filter rules; needs to be stored in network order */\n  unsigned magic;\n  /* Total length of header structure known to the sender */\n  unsigned header_size;\n  /* Properties string buffer */\n  unsigned properties_off;\n  unsigned properties_len;\n  /* Hashes of primary device properties strings, to let libudev subscribers\n    * use in-kernel socket filters; values need to be stored in network order */\n  unsigned filter_subsystem_hash;\n  unsigned filter_devtype_hash;\n  unsigned filter_tag_bloom_hi;\n  unsigned filter_tag_bloom_lo;\n} monitor_netlink_header;\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'8 bytes of "libudev"\n4 bytes of 0xfeedcafe\n4 bytes of header size\nX bytes of header\nACTION=add\\0\nDEVPATH=/class/input/input9/mouse2\\0\nSUBSYSTEM=input\\0\nSEQNUM=1064\\0\nPHYSDEVPATH=/devices/pci0000:00/0000:00:1d.1/usb2/2\xad2/2\xad2:1.0\\0\nPHYSDEVBUS=usb\\0\nPHYSDEVDRIVER=usbhid\\0\nMAJOR=13\\0\nMINOR=34\\0\n'})}),"\n",(0,i.jsx)(n.h3,{id:"10-application-receives-a-notification-from-udevd",children:'10. Application Receives a notification from "udevd"'}),"\n",(0,i.jsx)(n.p,{children:"Now that we've forged our udev message, the application subscribed should receive it, and treat it as though it was a real message emitted from udevd."}),"\n",(0,i.jsx)(n.h3,{id:"11-application-opens-virtual-device",children:"11. Application opens virtual device"}),"\n",(0,i.jsxs)(n.p,{children:["From the DEVPATH extracted from the received message, the corresponding ",(0,i.jsx)(n.code,{children:"libevdev"})," or legacy uapi ",(0,i.jsx)(n.code,{children:"joystick"})," library. Once connected to that device, the application should be able to use it as normal."]}),"\n",(0,i.jsx)(n.h2,{id:"keyboard--mouse",children:"Keyboard / Mouse"}),"\n",(0,i.jsx)(n.p,{children:"Keyboard and mouse emulation, instead of being done through udev devices in the Kernal, is done through wl-roots APIs directly. This is because the Kernal doesn't have a concept of a virtual keyboard or mouse, and instead relies on the compositor to handle these events. If we were to emulate a keyboard or mouse using udev, these devices may inadvertently be used by a shell that is running on the headless server, and may cause unintended side effects."}),"\n",(0,i.jsxs)(n.p,{children:["Instead, we use the ",(0,i.jsx)(n.a,{href:"https://wayland.app/protocols/virtual-keyboard-unstable-v1",children:"virtual-keyboard-unstable-v1"})," and ",(0,i.jsx)(n.a,{href:"https://wayland.app/protocols/wlr-virtual-pointer-unstable-v1",children:"wlr-virtual-pointer-unstable-v1"})," interfaces provided by wl-roots (and therefore Sway). These protocols are described using XML documents and are used to generate code to interact with the compositor. This code is generated by ",(0,i.jsx)(n.a,{href:"https://github.com/rajveermalviya/go-wayland/",children:"https://github.com/rajveermalviya/go-wayland/"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"helpful-references",children:"Helpful References"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://documentation.suse.com/sles/12-SP5/html/SLES-all/cha-udev.html",children:"https://documentation.suse.com/sles/12-SP5/html/SLES-all/cha-udev.html"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://insujang.github.io/2018-11-27/udev-device-manager-for-the-linux-kernel-in-userspace/",children:"https://insujang.github.io/2018-11-27/udev-device-manager-for-the-linux-kernel-in-userspace/"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/systemd/systemd/blob/main/src/libudev/libudev-monitor.c",children:"https://github.com/systemd/systemd/blob/main/src/libudev/libudev-monitor.c"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/pilebones/go-udev",children:"https://github.com/pilebones/go-udev"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.voidlinux.org/config/session-management.html",children:"https://docs.voidlinux.org/config/session-management.html"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.freedesktop.org/wiki/Software/systemd/multiseat/",children:"https://www.freedesktop.org/wiki/Software/systemd/multiseat/"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>r});var i=t(7294);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);